// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {Test, console} from "forge-std/Test.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {TssVerifier} from "tunnel-tss-router-contracts/TssVerifier.sol";
import {ITssVerifier} from "tunnel-tss-router-contracts/interfaces/ITssVerifier.sol";
import {TEOProxy} from "../src/TEOProxy.sol";
import {IPriceData} from "../src/interfaces/IPriceData.sol";
import {ITEOProxy} from "../src/interfaces/ITEOProxy.sol";
import {PacketDecoder} from "../src/libraries/PacketDecoder.sol";
import {MockConsumer} from "../src/mocks/MockConsumer.sol";
import {MockConsumerReentrance} from "../src/mocks/MockConsumerReentrance.sol";

contract TEOProxyTest is Test {
    TEOProxy internal proxy;
    MockConsumer internal consumer;
    MockConsumerReentrance internal consumerReEnt;
    TssVerifier internal bridge;
    address internal owner;
    address internal stranger;

    // Initial configuration values for the TssVerifier
    uint256 internal constant PX =
        0x06BE2ADAF05E8FFC701C9241D6E147FCD7FF4F72E1DA6AACD7158FA2A3919354;
    uint8 internal constant PARITY = 0x03;

    // Initial configuration values for the TEOProxy
    uint8 internal constant MIN_COUNT = 5;
    uint32 internal constant ORACLE_SCRIPT_ID = 14;
    bytes32 internal constant ORIGINATOR_HASH =
        0xe050352fd91310f74e0b5da3e1ea5d98274bab69eb08018216fcb872cda72253;

    // Helper function to craft a full 'proof' bytes
    function _craftRelayData(
        address rAddress,
        uint256 s,
        bytes memory m
    ) internal pure returns (bytes memory) {
        return abi.encodePacked(rAddress, s, m);
    }

    function setUp() public {
        owner = makeAddr("owner");
        stranger = makeAddr("stranger");

        bridge = new TssVerifier(0, bytes32(uint256(1)), owner);
        // Set initial keys for the bridge.
        vm.prank(owner);
        bridge.addPubKeyByOwner(0, PARITY, PX);

        // Deploy the proxy
        vm.prank(owner);
        proxy = new TEOProxy(
            MIN_COUNT,
            ORACLE_SCRIPT_ID,
            ITssVerifier(address(bridge)),
            owner,
            ORIGINATOR_HASH
        );

        // Deploy the MockConsumers
        consumer = new MockConsumer(address(proxy));
        consumerReEnt = new MockConsumerReentrance(proxy);
    }

    // --- Constructor Tests ---

    function testConstructor_Success() public view {
        (
            uint8 _minCount,
            uint64 _oracleScriptID,
            ITssVerifier _bridge,
            bytes32 _originatorHash
        ) = proxy.config();
        assertEq(_minCount, MIN_COUNT);
        assertEq(_oracleScriptID, ORACLE_SCRIPT_ID);
        assertEq(address(_bridge), address(bridge));
        assertEq(_originatorHash, ORIGINATOR_HASH);
        assertEq(proxy.owner(), owner);
    }

    function testConstructor_EmitsEvents() public {
        vm.expectEmit(true, true, true, true);
        emit ITEOProxy.SetMinCount(MIN_COUNT);
        vm.expectEmit(true, true, true, true);
        emit ITEOProxy.SetBridge(address(bridge));
        vm.expectEmit(true, true, true, true);
        emit ITEOProxy.SetOracleScriptID(ORACLE_SCRIPT_ID);
        vm.expectEmit(true, true, true, true);
        emit ITEOProxy.SetOriginatorHash(ORIGINATOR_HASH);
        vm.prank(owner);
        new TEOProxy(
            MIN_COUNT,
            ORACLE_SCRIPT_ID,
            ITssVerifier(address(bridge)),
            owner,
            ORIGINATOR_HASH
        );
    }

    // --- Setter Function Tests ---

    function testSetMinCount_Success() public {
        uint8 newMinCount = 9;
        vm.expectEmit(true, true, true, true);
        emit ITEOProxy.SetMinCount(newMinCount);
        vm.prank(owner);
        proxy.setMinCount(newMinCount);
        (uint8 _newMinCount, , , ) = proxy.config();
        assertEq(_newMinCount, newMinCount);
    }

    function testSetMinCount_RevertsWhenNotOwner() public {
        vm.prank(stranger);
        vm.expectRevert(
            abi.encodeWithSelector(
                Ownable.OwnableUnauthorizedAccount.selector,
                stranger
            )
        );
        proxy.setMinCount(10);
    }

    function testSetBridge_Success() public {
        address newBridge = makeAddr("newMockBridge");
        vm.expectEmit(true, true, true, true);
        emit ITEOProxy.SetBridge(newBridge);
        vm.prank(owner);
        proxy.setBridge(ITssVerifier(newBridge));
        (, , ITssVerifier _bridge, ) = proxy.config();
        assertEq(address(_bridge), newBridge);
    }

    function testSetBridge_RevertsWhenNotOwner() public {
        vm.prank(stranger);
        vm.expectRevert(
            abi.encodeWithSelector(
                Ownable.OwnableUnauthorizedAccount.selector,
                stranger
            )
        );
        proxy.setBridge(ITssVerifier(makeAddr("newMockBridge")));
    }

    function testSetOracleScriptID_Success() public {
        uint32 newOracleScriptID = 999;
        vm.expectEmit(true, true, true, true);
        emit ITEOProxy.SetOracleScriptID(newOracleScriptID);
        vm.prank(owner);
        proxy.setOracleScriptID(newOracleScriptID);
        (, uint64 _oracleScriptID, , ) = proxy.config();
        assertEq(_oracleScriptID, newOracleScriptID);
    }

    function testSetOracleScriptID_RevertsWhenNotOwner() public {
        vm.prank(stranger);
        vm.expectRevert(
            abi.encodeWithSelector(
                Ownable.OwnableUnauthorizedAccount.selector,
                stranger
            )
        );
        proxy.setOracleScriptID(999);
    }

    function testSetOriginatorHash_Success() public {
        bytes32 newOriginatorHash = keccak256(
            abi.encodePacked("newOriginatorHash")
        );
        vm.expectEmit(true, true, true, true);
        emit ITEOProxy.SetOriginatorHash(newOriginatorHash);
        vm.prank(owner);
        proxy.setOriginatorHash(newOriginatorHash);
        (, , , bytes32 _originatorHash) = proxy.config();
        assertEq(_originatorHash, newOriginatorHash);
    }

    function testSetOriginatorHash_RevertsWhenNotOwner() public {
        vm.prank(stranger);
        vm.expectRevert(
            abi.encodeWithSelector(
                Ownable.OwnableUnauthorizedAccount.selector,
                stranger
            )
        );
        proxy.setOriginatorHash(
            keccak256(abi.encodePacked("newOriginatorHash"))
        );
    }

    // --- relay Tests ---

    function testRelay_Success() public {
        string[] memory expectedKeys = new string[](6);
        expectedKeys[0] = "Gold";
        expectedKeys[1] = "Silver";
        expectedKeys[2] = "Copper";
        expectedKeys[3] = "Platinum";
        expectedKeys[4] = "HRC Steel";
        expectedKeys[5] = "Iron Ore";
        uint256[] memory expectedValues = new uint256[](6);
        expectedValues[0] = 343203000000;
        expectedValues[1] = 3629900000;
        expectedValues[2] = 474020000;
        expectedValues[3] = 120870000000;
        expectedValues[4] = 86200000000;
        expectedValues[5] = 9538000000;

        assertEq(proxy.lastResolveTime(), 0);
        for (uint256 i = 0; i < 6; i++) {
            (uint256 price, uint256 lastUpdated) = consumer.prices(
                expectedKeys[i]
            );
            assertEq(price, 0);
            assertEq(lastUpdated, 0);
        }

        bytes memory relayData = _craftRelayData(
            0xA7c079eFf42fa8f23D51F3b8ac4B68C1E2A738e5,
            0xB731C6F48E1255D24829A561AB0A25BFBF3D7BAD361D6B0F47DBF567201CE305,
            hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684ED0850000000000187EBA89CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E059000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000684ED085000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004FE87E2EC000000000D85BE0E0000000001C40F8A00000001C2469D5800000001411EB9E00000000023882548000000000000000"
        );
        uint256 warpTo = 12345678;
        vm.warp(warpTo);
        vm.prank(stranger);
        proxy.relay(IPriceData(address(consumer)), relayData);

        assertEq(
            proxy.lastResolveTime(),
            uint64(1749995653),
            "lastResolveTime should be updated"
        );
        for (uint256 i = 0; i < 6; i++) {
            (uint256 price, uint256 lastUpdated) = consumer.prices(
                expectedKeys[i]
            );
            assertEq(price, expectedValues[i]);
            assertEq(lastUpdated, warpTo);
        }
    }

    function testRelay_Success_With_A_Newer_Data() public {
        // data 1
        string[] memory expectedKeys = new string[](6);
        expectedKeys[0] = "Gold";
        expectedKeys[1] = "Silver";
        expectedKeys[2] = "Copper";
        expectedKeys[3] = "Platinum";
        expectedKeys[4] = "HRC Steel";
        expectedKeys[5] = "Iron Ore";
        uint256[] memory expectedValues = new uint256[](6);
        expectedValues[0] = 343203000000;
        expectedValues[1] = 3629900000;
        expectedValues[2] = 474020000;
        expectedValues[3] = 120870000000;
        expectedValues[4] = 86200000000;
        expectedValues[5] = 9538000000;

        assertEq(proxy.lastResolveTime(), 0);
        for (uint256 i = 0; i < 6; i++) {
            (uint256 price, uint256 lastUpdated) = consumer.prices(
                expectedKeys[i]
            );
            assertEq(price, 0);
            assertEq(lastUpdated, 0);
        }

        bytes memory relayData = _craftRelayData(
            0xA7c079eFf42fa8f23D51F3b8ac4B68C1E2A738e5,
            0xB731C6F48E1255D24829A561AB0A25BFBF3D7BAD361D6B0F47DBF567201CE305,
            hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684ED0850000000000187EBA89CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E059000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000684ED085000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004FE87E2EC000000000D85BE0E0000000001C40F8A00000001C2469D5800000001411EB9E00000000023882548000000000000000"
        );
        uint256 warpTo1 = 1111111;
        vm.warp(warpTo1);
        vm.prank(stranger);
        proxy.relay(IPriceData(address(consumer)), relayData);

        assertEq(
            proxy.lastResolveTime(),
            uint64(1749995653),
            "lastResolveTime should be updated"
        );
        for (uint256 i = 0; i < 6; i++) {
            (uint256 price, uint256 lastUpdated) = consumer.prices(
                expectedKeys[i]
            );
            assertEq(price, expectedValues[i]);
            assertEq(lastUpdated, warpTo1);
        }

        // data 2
        // update prices of each symbols
        uint256[] memory newExpectedValues = new uint256[](6);
        newExpectedValues[0] = 341339000000;
        newExpectedValues[1] = 3650600000;
        newExpectedValues[2] = 482940000;
        newExpectedValues[3] = 122400000000;
        newExpectedValues[4] = 85807000000;
        newExpectedValues[5] = 9538000000;

        relayData = _craftRelayData(
            0x68fa2DAFcC8D58a2dd6B5E066001D3db82c0070D,
            0x6999B5A9698F9EB4DF1B6E42F8DAD477DB86513658FD2C10ACA5FCB08BF4EFD5,
            hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684FC82D00000000001B4B9889CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E369000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000684FC82D000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004F7963CCC000000000D997BC40000000001CC914600000001C7F9BC80000000013FA7EE9C0000000023882548000000000000000"
        );
        uint256 warpTo2 = 222222;
        vm.warp(warpTo2);
        vm.prank(stranger);
        proxy.relay(IPriceData(address(consumer)), relayData);

        assertEq(
            proxy.lastResolveTime(),
            uint64(1750059053),
            "lastResolveTime should be updated"
        );
        for (uint256 i = 0; i < 6; i++) {
            (uint256 price, uint256 lastUpdated) = consumer.prices(
                expectedKeys[i]
            );
            assertEq(price, newExpectedValues[i]);
            if (newExpectedValues[i] == expectedValues[i]) {
                assertEq(lastUpdated, warpTo1);
            } else {
                assertEq(lastUpdated, warpTo2);
            }
        }
    }

    function testRelay_Reverts_InvalidProofLength() public {
        bytes memory relayData = hex"0102030405";
        vm.expectRevert(ITEOProxy.InvalidProofLength.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);
    }

    function testRelay_Reverts_VerificationFail() public {
        bytes memory relayData = _craftRelayData(
            // invalid rAddr
            0xa7C079eff42fa8F23d51F3B8Ac4B68c1E2A738e6,
            0xB731C6F48E1255D24829A561AB0A25BFBF3D7BAD361D6B0F47DBF567201CE305,
            hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684ED0850000000000187EBA89CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E059000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000684ED085000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004FE87E2EC000000000D85BE0E0000000001C40F8A00000001C2469D5800000001411EB9E00000000023882548000000000000000"
        );
        vm.prank(stranger);
        vm.expectRevert(ITEOProxy.VerificationFail.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);

        relayData = _craftRelayData(
            0xA7c079eFf42fa8f23D51F3b8ac4B68C1E2A738e5,
            // invalid s
            0xB731C6F48E1255D24829A561AB0A25BFBF3D7BAD361D6B0F47DBF567201CE306,
            hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684ED0850000000000187EBA89CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E059000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000684ED085000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004FE87E2EC000000000D85BE0E0000000001C40F8A00000001C2469D5800000001411EB9E00000000023882548000000000000000"
        );
        vm.prank(stranger);
        vm.expectRevert(ITEOProxy.VerificationFail.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);

        relayData = _craftRelayData(
            0xA7c079eFf42fa8f23D51F3b8ac4B68C1E2A738e5,
            0xB731C6F48E1255D24829A561AB0A25BFBF3D7BAD361D6B0F47DBF567201CE305,
            // invalid message
            hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684ED0850000000000187EBA89CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E059000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000684ED085000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004FE87E2EC000000000D85BE0E0000000001C40F8A00000001C2469D5800000001411EB9E00000000023882549000000000000000"
        );
        vm.prank(stranger);
        vm.expectRevert(ITEOProxy.VerificationFail.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);
    }

    function testRelay_Reverts_Reentrancy() public {
        bytes memory relayData = _craftRelayData(
            0xA7c079eFf42fa8f23D51F3b8ac4B68C1E2A738e5,
            0xB731C6F48E1255D24829A561AB0A25BFBF3D7BAD361D6B0F47DBF567201CE305,
            hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684ED0850000000000187EBA89CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E059000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000684ED085000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004FE87E2EC000000000D85BE0E0000000001C40F8A00000001C2469D5800000001411EB9E00000000023882548000000000000000"
        );
        consumerReEnt.setWhatToBeCalledNext(consumer, relayData);

        uint256 warpTo = 12345678;
        vm.warp(warpTo);
        vm.prank(stranger);
        vm.expectRevert(ReentrancyGuard.ReentrancyGuardReentrantCall.selector);
        proxy.relay(consumerReEnt, relayData);
    }

    function testRelay_Reverts_InvalidOriginatorHash() public {
        bytes memory message = hex"9DB387E9E1198E2A24E570A362551A01BCC270FEF1C4B58F9BEBE99D7D366F50000000006851365600000000001E22A689CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E81800000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000068513656000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004EB2E8084000000000D96B7C20000000001C97F2400000001D149EC100000000140056464000000002379D72C000000000000000";
        bytes memory relayData = _craftRelayData(
            0xe6E4d1D629F85C330693A556E6934d6F053BbFB2,
            0x74221E66273A376DAF2594F3D3030FE63C6789EF245CA71ECEA9890C842B480D,
            message
        );
        PacketDecoder.TssMessage memory tssm = PacketDecoder.decodeTssMessage(message);
        assertEq(tssm.originatorHash, 0x9DB387E9E1198E2A24E570A362551A01BCC270FEF1C4B58F9BEBE99D7D366F50);

        uint256 warpTo = 12345678;
        vm.warp(warpTo);
        vm.prank(stranger);
        vm.expectRevert(ITEOProxy.InvalidOriginatorHash.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);
    }

    function testRelay_Reverts_EncoderTypeNotPartialABI() public {
        // EncodeType = PROTO
        bytes memory message = hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684FE41C00000000001B97B489CBF5AF01E2ADB30A0966726F6D5F7363616E100E1A01002006280530C4C70B38064096C8BFC206489CC8BFC20650015A790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004F96F428C000000000D8FC1880000000001CA4EA900000001CE91BD68000000013FA7EE9C00000000238825480";
        bytes memory relayData = _craftRelayData(
            0x1202a520B39616fcdaBecDcA4c547C0B1527bCb2,
            0x0F81DDBA4EC53BCEA58BBC3B5B814790E27BDF56AFE2B247CED51FF93C8A8CE2,
            message
        );
        PacketDecoder.TssMessage memory tssm = PacketDecoder.decodeTssMessage(message);
        assertEq(uint8(tssm.encoderType), uint8(PacketDecoder.EncoderType.PROTO));
        vm.prank(stranger);
        vm.expectRevert(ITEOProxy.EncoderTypeNotPartialABI.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);

        // EncodeType = FULL_ABI
        message = hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684FE9A800000000001BA79089CBF5AF45B4E7EA00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000E00000000000000000000000000000000000000000000000000000000000001A000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000002E3D4000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000684FE9A300000000000000000000000000000000000000000000000000000000684FE9A8000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001E0000000000000000000000000000000000000000000000000000000000000000966726F6D5F7363616E00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004F78E9BAC000000000D8775820000000001C8135F00000001CD903F70000000013FA7EE9C0000000023882548000000000000000";
        relayData = _craftRelayData(
            0xfE6D4A6622B75a1f8Db58C21eAb944B3cc925d2A,
            0xCB1AC5B1555C364E05BCCDDDD91A7B232A6A9578906B48A4A3747AEF3A0E7464,
            message
        );
        tssm = PacketDecoder.decodeTssMessage(message);
        assertEq(uint8(tssm.encoderType), uint8(PacketDecoder.EncoderType.FULL_ABI));
        vm.prank(stranger);
        vm.expectRevert(ITEOProxy.EncoderTypeNotPartialABI.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);
    }

    function testRelay_Reverts_RequestNotSuccessfullyResolved() public {
        // This case will never be reached since the TSS proof will not be available for any unresolved request
    }

    function testRelay_Reverts_OracleScriptIDMismatch() public {
        bytes memory message = hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684FED2000000000001BB04F89CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000C000000000000000000000000000000000000000000000000000000000002E3E5000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000684FED2000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000002C0000002096FAC1EC49F38C79900A61E5F85D54D0E51E2D5945D8B713156E978D5A512281000000000012D6870000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002400000020D4AD88C4C513104A0C03B739CD5B669926D8C4EEEE0C86E726BD68E943E67B2200000000000000000000000000000000000000000000000000000000";
        bytes memory relayData = _craftRelayData(
            0x47893084289EF1FAaa94F25913a64DE8750Cf03E,
            0x8E8768228CD8787DC83F2C8AC09AF2FA09612DA255D3D1E68C2F52FFC8D28618,
            message
        );
        PacketDecoder.TssMessage memory tssm = PacketDecoder.decodeTssMessage(message);
        assertEq(uint8(tssm.encoderType), uint8(PacketDecoder.EncoderType.PARTIAL_ABI));

        PacketDecoder.PartialResult memory pr = PacketDecoder.decodePartialResult(tssm.packet);
        assertEq(pr.oracleScriptID, uint64(12));

        uint256 warpTo = 12345678;
        vm.warp(warpTo);
        vm.prank(stranger);
        vm.expectRevert(ITEOProxy.OracleScriptIDMismatch.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);
    }

    function testRelay_Reverts_InvalidMinCount() public {
        bytes memory message = hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684FF0C500000000001BBA4789CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E3F2000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000684FF0C5000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004F78DA788000000000D8B8F500000000001CA2A0A00000001CE28D5F0000000013FA7EE9C0000000023882548000000000000000";
        bytes memory relayData = _craftRelayData(
            0x745fB1dd0F31d23c2805c6B44831EF9843994EF3,
            0xD9B8768A2C732F55E710DD35BBFCC536BD5BDC33C77C05C06F3BE2E23ED50317,
            message
        );
        PacketDecoder.TssMessage memory tssm = PacketDecoder.decodeTssMessage(message);
        assertEq(uint8(tssm.encoderType), uint8(PacketDecoder.EncoderType.PARTIAL_ABI));

        PacketDecoder.PartialResult memory pr = PacketDecoder.decodePartialResult(tssm.packet);
        assertEq(pr.minCount, uint64(4));

        uint256 warpTo = 12345678;
        vm.warp(warpTo);
        vm.prank(stranger);
        vm.expectRevert(ITEOProxy.InvalidMinCount.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);
    }

    function testRelay_Reverts_InvalidTimestamp() public {
        string[] memory expectedKeys = new string[](6);
        expectedKeys[0] = "Gold";
        expectedKeys[1] = "Silver";
        expectedKeys[2] = "Copper";
        expectedKeys[3] = "Platinum";
        expectedKeys[4] = "HRC Steel";
        expectedKeys[5] = "Iron Ore";
        uint256[] memory expectedValues = new uint256[](6);
        expectedValues[0] = 343203000000;
        expectedValues[1] = 3629900000;
        expectedValues[2] = 474020000;
        expectedValues[3] = 120870000000;
        expectedValues[4] = 86200000000;
        expectedValues[5] = 9538000000;

        assertEq(proxy.lastResolveTime(), 0);
        for (uint256 i = 0; i < 6; i++) {
            (uint256 price, uint256 lastUpdated) = consumer.prices(
                expectedKeys[i]
            );
            assertEq(price, 0);
            assertEq(lastUpdated, 0);
        }

        bytes memory relayData = _craftRelayData(
            0xA7c079eFf42fa8f23D51F3b8ac4B68C1E2A738e5,
            0xB731C6F48E1255D24829A561AB0A25BFBF3D7BAD361D6B0F47DBF567201CE305,
            hex"E050352FD91310F74E0B5DA3E1EA5D98274BAB69EB08018216FCB872CDA7225300000000684ED0850000000000187EBA89CBF5AF7BAE7CD8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000E0000000000000000000000000000000000000000000000000000000000000000E000000000000000000000000000000000000000000000000000000000002E059000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000684ED085000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000790000000600000004476F6C640000000653696C76657200000006436F7070657200000008506C6174696E756D0000000948524320537465656C0000000849726F6E204F7265000000060000004FE87E2EC000000000D85BE0E0000000001C40F8A00000001C2469D5800000001411EB9E00000000023882548000000000000000"
        );
        uint256 warpTo = 12345678;
        vm.warp(warpTo);
        vm.prank(stranger);
        proxy.relay(IPriceData(address(consumer)), relayData);

        assertEq(
            proxy.lastResolveTime(),
            uint64(1749995653),
            "lastResolveTime should be updated"
        );
        for (uint256 i = 0; i < 6; i++) {
            (uint256 price, uint256 lastUpdated) = consumer.prices(
                expectedKeys[i]
            );
            assertEq(price, expectedValues[i]);
            assertEq(lastUpdated, warpTo);
        }

        // relay again
        warpTo += 12345678;
        vm.warp(warpTo);
        vm.prank(stranger);
        vm.expectRevert(ITEOProxy.InvalidTimestamp.selector);
        proxy.relay(IPriceData(address(consumer)), relayData);
    }
}
